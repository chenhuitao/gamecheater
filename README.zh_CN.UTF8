  休息不好就不可能工作好，偶尔打打游戏，可是GNU/Linux下游戏真是少啊。

  如果你是电脑高手的话，那么用gdb (The GNU Debugger) 吧，比这个功能强大多了。

  这一阵子在用dosbox玩一些老游戏，没有修改器玩的真是辛苦。怎么原来的游戏大多要练级？ 不爽！
郁闷。。。。。。 gdb用起来太复杂。于是写了一个修改器，帮助我迅速通关。哈哈。 ^_^

  这个修改器还很初级，没有什么人性化的设计。 我想没有帮助也能使用吧。先选择你要修改的进程，双击
对应的列。在新的对话框里输入你要查找的数据类型和数值。在数值输入框上按回车开始搜索。状态栏会报告
有多少命中的数据。但是只显示前面8个地址。重复搜索后找到你希望更改的地址后双击填入新的数值。好运。

  为了图省事，都用GtkTreeView来显示数值。在搜索的过程中也没有设计什么对象，结构之类的。就是用
个单链表来存储内存地址。而且现在也没有获得精确的进程所使用的内存的范围，所有/proc/pid/maps里面
的地址可读写的都扫描了一遍。等有时间好好看看gdb代码，看看是否有帮助。如果你这方面的知识，或者有
好的建议，可以给我 email，告诉我，我尽量改进。或者你写了一个更好的程序，那么请告诉我，我也要用。

  数据类型是要查找的数据在机器中的长度，要求输入的查找数值都是无符号的整数。这个查找也不是全内存
搜索，它读取/proc/pid/maps文件，只搜索可读写的部分，另外库文件的内存和设备文件的内存不扫描。
扫描时按照数据类型来处理。如果是uint16，就两个字节（一个字节8－bit，char类型）两个字节的扫描。
如果你要找的数据是以奇地址开始的，那么很不幸的将被略过。一个十六位的数据存在奇数地址上，这种情
况非常少。还有如果是模拟器游戏，可能模拟的CPU数据字节位序和你的机器不一样。我的X86是
little-endian，如果模拟器的存储是big-endian。那么大于8－bit的内存表示的数值是不同解释的。

  负数和浮点数搜索其实也可以实现，不过这要你有一定的计算机知识了。实际上搜索的实质就是在内存中
的数据和你要求的数据的比较。如在x86上的int类型是32－bit长。如果你想搜索-1，其实32－bit的-1和
4294967295(0xFFFFFFFF)在内存中是一样的，只是解释不同而已。那么你搜索4294967295等于搜索-1。
同理，你知道浮点数的表示方法的话，也可以转成整形数来搜索。只是要小心精度。

  我的邮箱是h980501427@hotmail.com，欢迎来信指导。不过上网对我来说现在还不是很随意。惨啊！
如不能及时回复，请见谅。
